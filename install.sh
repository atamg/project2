#!/bin/bash

# Configuration
DEPLOYMENT_ENV=${DEPLOYMENT_ENV:-kvm}
export DEPLOYMENT_ENV
INSTALL_DEPENDENCY=${INSTALL_DEPENDENCY:-false}
LOG_DIR="./reports"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# Required tools
REQUIRED_TOOLS=(
    "terraform"
    "ansible"
    "kubectl"
    "helm"
    "aws"
    "docker"
    "git"
    "genisoimage"
)

# Log functions
log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Detect OS
detect_os() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        OS=$ID
        VERSION=$VERSION_ID
    else
        log_error "Unsupported operating system."
        exit 1
    fi
}

# Install dependency based on OS
install_dependency() {
    local tool=$1

    case "$OS" in
        ubuntu|debian)
            sudo apt-get update && sudo apt-get install -y "$tool"
            ;;
        centos|rhel|fedora)
            sudo yum install -y "$tool"
            ;;
        *)
            log_error "Unsupported OS: $OS"
            exit 1
            ;;
    esac
}

# Check and install required tools
check_and_install_tools() {
    for tool in "${REQUIRED_TOOLS[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            log_warn "$tool is not installed. Installing..."
            install_dependency "$tool"
        else
            log_info "$tool is already installed."
        fi
    done
}

# Create log directory
create_log_dir() {
    if [[ ! -d "$LOG_DIR" ]]; then
        mkdir -p "$LOG_DIR"
        log_info "Log directory created at $LOG_DIR"
    fi
}

generate_ansible_hosts_vars() {
    
    echo "# Generated by generate_vars_yml.sh" > vars.yaml

    # Jump server
    jq -r '.jump_server_map.value | to_entries[] | "jump_server_ip: \(.value)"' nodes.json >> vars.yaml

    # Masters
    jq -r '.master_nodes_map.value | to_entries[] | "master_\(.key | split("-")[1])_ip: \(.value)"' nodes.json >> vars.yaml

    # Workers
    jq -r '.worker_nodes_map.value | to_entries[] | "worker_\(.key | split("-")[1])_ip: \(.value)"' nodes.json >> vars.yaml
    log_info "Ansible variables generated in vars.yaml"
}

generate_ansible_inventory() {
    # Generates a valid Ansible inventory file in YAML format from nodes.json
    inventory_file="../../ansible/inventory/hosts.yaml"
    echo "# Generated by generate_ansible_inventory" > "$inventory_file"
    echo "all:" >> "$inventory_file"
    echo "  vars:" >> "$inventory_file"
    echo "    ansible_user: 'ata'" >> "$inventory_file"
    echo "    ansible_ssh_common_args: '-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ForwardAgent=yes'" >> "$inventory_file"
    echo "    ansible_connection: 'ssh'" >> "$inventory_file"
    echo "    ansible_port: 22" >> "$inventory_file"
    echo "    ansible_become: 'yes'" >> "$inventory_file"
    echo "  children:" >> "$inventory_file"

    # Jump server group
    echo "    jump_server:" >> "$inventory_file"
    echo "      hosts:" >> "$inventory_file"
    jq -r '.jump_server_map.value | to_entries[] | "        jump-server:\n          ansible_host: \(.value)"' nodes.json >> "$inventory_file"

    # Masters group
    echo "    masters:" >> "$inventory_file"
    echo "      hosts:" >> "$inventory_file"
    jq -r '.master_nodes_map.value | to_entries[] | "        \(.key):\n          ansible_host: \(.value)"' nodes.json >> "$inventory_file"

    # Workers group
    echo "    workers:" >> "$inventory_file"
    echo "      hosts:" >> "$inventory_file"
    jq -r '.worker_nodes_map.value | to_entries[] | "        \(.key):\n          ansible_host: \(.value)"' nodes.json >> "$inventory_file"
    

    log_info "Ansible inventory generated at $inventory_file"
}

# Deploy infrastructure using Terraform
deploy_infrastructure() {
    log_info "Deploying infrastructure using Terraform for environment: $DEPLOYMENT_ENV ..."
    if [[ $DEPLOYMENT_ENV == "vbox" ]]; then
        log_warn "Using VirtualBox environment. Ensure VirtualBox is installed and configured."
        cd ./terraform/vbox
        terraform fmt
        terraform validate
        terraform init
        TF_LOG=DEBUG TF_LOG_PATH=terraform-debug.log terraform apply -auto-approve
        if [[ $? -ne 0 ]]; then
            log_error "Terraform deployment failed."
            exit 1
        fi
        terraform output -json all_nodes > nodes.json
        log_info "Infrastructure deployed successfully."
    elif [[ "$DEPLOYMENT_ENV" == "aws" ]]; then
        log_warn "Using AWS environment. Ensure AWS CLI is configured."
        cd ./terraform/aws
        terraform fmt
        terraform validate
        terraform init
        terraform apply -auto-approve
        if [[ $? -ne 0 ]]; then
            log_error "Terraform deployment failed."
            exit 1
        fi
        terraform output -json > nodes.json
        log_info "Infrastructure deployed successfully."
    elif [[ "$DEPLOYMENT_ENV" == "kvm" ]]; then
        log_warn "Using KVM environment. Ensure libvirt is installed and configured."
        cd ./terraform/kvm
        terraform fmt
        terraform validate
        terraform init
        terraform apply -parallelism=1 -auto-approve
        if [[ $? -ne 0 ]]; then
            log_error "Terraform deployment failed."
            exit 1
        fi
        terraform output -json > nodes.json
        log_info "Infrastructure deployed successfully."
    fi
    
    # Extract and write Ansible variables in YAML format
    log_info "Generating Ansible variables from nodes.json ..."
    
    generate_ansible_hosts_vars
    
    log_info "Generating Ansible inventory from nodes.json ..."
    generate_ansible_inventory

    log_info "Waiting for jump server SSH before configuration..."
    wait_for_jump_server_ssh

    log_info "Configuring jump server"
    configure_jump_server

    log_info "Hardening jump server"
    harden_jump_server
}

# Destroy infrastructure using Terraform

destroy_infrastructure() {
    log_info "Destroying infrastructure using Terraform for environment: $DEPLOYMENT_ENV ..."
    if [[ $DEPLOYMENT_ENV == "vbox" ]]; then
        cd ./terraform/vbox
        terraform destroy -auto-approve
        if [[ $? -ne 0 ]]; then
            log_error "Terraform destroy failed."
            exit 1
        fi
        log_info "Infrastructure destroyed successfully."
    elif [[ "$DEPLOYMENT_ENV" == "aws" ]]; then
        cd ./terraform/aws
        terraform destroy -auto-approve
        if [[ $? -ne 0 ]]; then
            log_error "Terraform destroy failed."
            exit 1
        fi
        log_info "Infrastructure destroyed successfully."
    elif [[ "$DEPLOYMENT_ENV" == "kvm" ]]; then
        cd ./terraform/kvm
        terraform destroy -auto-approve
        if [[ $? -ne 0 ]]; then
            log_error "Terraform destroy failed."
            exit 1
        fi
        log_info "Infrastructure destroyed successfully."
    else
        log_error "Unknown DEPLOYMENT_ENV: $DEPLOYMENT_ENV"
        exit 1
    fi
}

# Configure Kubernetes cluster using Ansible
configure_kubernetes() {
    log_info "Configuring Kubernetes cluster using Ansible for environment: $DEPLOYMENT_ENV ..."
    ansible-playbook -e deployment_env=$DEPLOYMENT_ENV -i ansible/inventory/hosts.yml --extra-vars "@vars.yaml" ansible/playbooks/k8s-cluster.yml
    if [[ $? -ne 0 ]]; then
        log_error "Kubernetes configuration failed."
        exit 1
    fi
    log_info "Kubernetes cluster configured successfully."
}

# Deploy applications using Helm
deploy_applications() {
    log_info "Deploying applications using Helm..."
    helm repo update
    helm upgrade --install my-app ./kubernetes/charts/my-app
    if [[ $? -ne 0 ]]; then
        log_error "Application deployment failed."
        exit 1
    fi
    log_info "Applications deployed successfully."
}

# Configure jump server using Ansible
configure_jump_server() {
    log_info "Configuring jump server using Ansible for environment: $DEPLOYMENT_ENV ..."
    ansible-playbook -e deployment_env=$DEPLOYMENT_ENV -i ../../ansible/inventory/hosts.yaml ../../ansible/playbooks/jump-server.yml --vault-password-file ~/.ansible/vault.pass
    if [[ $? -ne 0 ]]; then
        log_error "Jump server configuration failed."
        exit 1
    fi
    log_info "Jump server configured successfully."
}

# Wait for SSH to become available on the jump server
wait_for_jump_server_ssh() {
    local nodes_json_path="nodes.json"
    local jump_server_ip
    local max_retries=30
    local retry_interval=10
    local attempt=1

    if ! command -v jq &> /dev/null; then
        log_error "jq is required for extracting jump server IP. Please install jq."
        exit 1
    fi

    if [[ ! -f $nodes_json_path ]]; then
        log_error "$nodes_json_path not found. Cannot determine jump server IP."
        exit 1
    fi

    jump_server_ip=$(jq -r '.jump_server_map.value | to_entries[0].value' "$nodes_json_path")
    if [[ -z "$jump_server_ip" || "$jump_server_ip" == "null" ]]; then
        log_error "Could not extract jump server IP from $nodes_json_path."
        exit 1
    fi

    log_info "Waiting for SSH to become available on jump server ($jump_server_ip)..."
    while (( attempt <= max_retries )); do
        if nc -z -w 5 "$jump_server_ip" 22; then
            log_info "SSH is available on jump server ($jump_server_ip)."
            return 0
        else
            log_warn "Attempt $attempt/$max_retries: SSH not available yet. Retrying in $retry_interval seconds..."
            sleep $retry_interval
            ((attempt++))
        fi
    done
    log_error "SSH did not become available on jump server ($jump_server_ip) after $((max_retries * retry_interval)) seconds."
    exit 1
}

# Harden jump server using Ansible
harden_jump_server() {
    log_info "Hardening jump server using Ansible for environment: $DEPLOYMENT_ENV ..."
    ansible-playbook -e deployment_env=$DEPLOYMENT_ENV -i ../../ansible/inventory/hosts.yaml ../../ansible/playbooks/hardening_jump_server.yml --vault-password-file ~/.ansible/vault.pass
    if [[ $? -ne 0 ]]; then
        log_error "Jump server hardening failed."
        exit 1
    fi
    log_info "Jump server hardening has been done successfully."
}


# Main script execution
main() {
    detect_os
    create_log_dir

    # Check for --destroy argument
    if [[ "$1" == "--destroy" ]]; then
        destroy_infrastructure
        exit 0
    fi

    if [[ "$INSTALL_DEPENDENCY" == "true" ]]; then
        check_and_install_tools
    else
        log_info "Dependency installation is disabled. Skipping..."
    fi
    
    if [[ "$1" == "--infra" ]]; then
        deploy_infrastructure
        exit 0
    fi

    if [[ "$1" == "--cluster" ]]; then
        configure_kubernetes
        exit 0
    fi

    if [[ "$1" == "--apps" ]]; then
        deploy_applications
        exit 0
    fi

    deploy_infrastructure
    #configure_kubernetes
    #deploy_applications
}

main "$@"